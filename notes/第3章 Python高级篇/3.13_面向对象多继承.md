

## 面向对象多继承

```python
# 继承时，先找左后找右
class A(object):
    def f1(self):
        print('A')
class B(object):
    def f1(self):
        print('B')
class C(A,B):
    pass
obj = C()
```

### 经典类和新式类

1. `python2`：经典类和新式类

   如果自己活自己的前辈只要有人继承`object`，那么此类就是新式类

2. `python3`：新式类

3. 区别：查找的顺序不一样

   - 经典类：一条道走到黑(深度优先)
   - 新式类：`C3`算法实现

```python
class A(object):
    def f1(self):
        print('A')
class B(A):
    def f1(self):
        print('B')
class C(B):
    pass
class D(object):
    pass
class E(D,C):
    pass
class F(object):
    pass
class G(F):
    pass
class H(C,G):
    pass
class Foo(E,H):
    pass
obj = Foo()
print(E.__mro__)
```

![多继承顺序图](D:\repository\PythonNotes\images\多继承顺序图.png)

### 注意事项

`super`是遵循`__mro__`执行顺序

## 网络基础

1. 软件

   - 客户端：CS架构，client      -->  server
   - 浏览器：BS架构，browser  -->  server

2. 如何实现相互通信

   需求一：编写两个软件，软件之间相互通信

   总结：

   1. 相互通信本质发送0101010101
   2. 交换机作用
   3. 通过`ipconfig`查看自己的内网`IP`
   4. 公网`IP`，掏钱

3. 基于`socket`模块实现网络通信

```python
import socket

# 创建服务端socket对象
server = socket.socket()
# 绑定IP和端口
server.bind(('192.168.0.1',8000))
# 后边可以等5个人
server.listen(5)
# 等待客户端来连接，如果没人来就一直等待
# conn是客户端和服务端连接的对象；服务端以后要通过该对象进行收发数据
# addr是客户端的地址信息
# 默认阻塞，只要有客户端进行连接，则获取客户端连接然后开始进行通信
conn,addr = server.accept()
print(conn,addr)
# 通过对象去获取(王晓东通过伞给我发送的消息)
# 1024表示：服务端通过伞获取数据时，一次性最多拿1024字节
data = conn.recv(1024)
print(data)
# 服务端通过连接对象伞给客户端回复一个消息
conn.send(b'stop')
# 与客户端断开连接(放开那把伞)
conn.close()
# 关闭服务端的服务
server.close()
```

```python
import socket

client = socket.socket()
# 表示王晓东向服务端发起连接请求(递伞)
# 默认阻塞，去连接，直到连接成功后才会继续向下走
client.connect(('192.168.0.1',8000))
# 连接上服务端后，向服务端发送消息
client.send(b'hello')
# 王晓东等待服务端给他发送消息
data = client.recv(1024)
print(data)
# 关闭自己
client.close()
```

```python
# 服务端
import socket

server = socket.socket()
server.bind(('192.168.0.1',8001))
server.listen(5)
while 1:
    porint('server is working....')
    conn,addr = server.accept()
    # 字节类型
    while 1:
        try:
            data = conn.recv(1024)
            if data == b'exit':
                break
            response = data + b'SB'
            conn.send(response)
        except Exception as e:
            break
    conn.close()
```

```python
# 客户端
import socket
sk = socket.socket()
sk.connect(('192.168.0.1',8001))
while 1:
    name = input("请输入姓名：")
    sk.send(name.encode('utf-8'))
    if name == 'exit':
        break
    rece = sk.recv(1024)
    print(rece.decode('utf-8'))
sk.close()
```

为什么网络通信发送的是字节不是字符串？

`python3`，`send/recv`都是字节

`python2`，`send/recv`都是字符串

服务端：

`accept`，阻塞：等待客户端来连接

`recv`，阻塞：等待客户端发来数据

客户端：

`connect`，阻塞：一直在连接，知道连接成功才往下运行其他代码

`recv`，阻塞：等待服务端发来数据

## 作业

1. 用户登陆作业
   1. 服务端
      - 等待客户端发送数据：用户名、密码
      - 本地文件中查看用户名密码是否合法
      - 合法：登陆成功
      - 否则：用户名或密码错误
   2. 客户端
      - 用户输入：用户名、密码
      - 发送到服务端进行校验

2. 聊天工具(10086)
   1. 服务端
      - 接受客户端发送的信息
      - 检查是否有某些指定关键字
        - 根据关键字回复指定消息
   2. 客户端
      - 持续问答
      - 关闭

作业1

```python
# 服务端
import socket

server = socket.socket()  # TCP协议
IP_PORT = ('192.168.0.1',8001)
server.bind(IP_PORT)
server.listen(5)
while 1:
    conn,addr = server.accept()
    while 1:
        try:
            data = conn.recv(1024).decode('utf8')
            print('就收信息：',data)
            user,pwd = data.split('|')
            # 文件操作
            flag = False
            with open('account','r') as f:
                for line in f:
                    username,password = line.strip().split(':')
                    if username == user and password == pwd:
                        flag = True
                        break
            if flag:
                conn.send(b'success')
            else:
                conn.send(b'fail')
        except Exception as e:
            break
```

 

```python
# 客户端
import socket

sock = socket.socket()  # TCP协议
sock.connect('192.168.0.1',8001)
while 1:
    user = input('用户名>>>')
    pwd = input('密码>>>')
    val = ("%s|%s"%(user,pwd)).encode('utf8')
    sock.send(val)
    response = sock.recv(1024)
    print(response.decode('utf8'))
    if response.decode('utf8') == 'success':
        break
    else:
        print('用户名或密码错误')
        continue
```

