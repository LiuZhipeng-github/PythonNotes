# 函数名、闭包和迭代器

---

1. **函数名的应用**

   1. 函数名的命名规范和变量是一样的，函数名其实就是变量名

   2. 函数名可以作为参数传递给函数

   3. 可以作为列表中的元素进行存储

   4. 可以作为函数的返回值

      ```python
      def func():
          print('我是一个小小的函数')
      
      a = func
      print(a)
      func()
      a()
      func = 3
      print(func)
      ```

      ```python
      a = 10
      b = 20
      c = 30
      lst = [a, b, c]
      print(lst)
      
      def func1():
          print('我是1')
      def func2():
          print('我是2')
      def func3():
          print('我是3')
      lst = [func1, func2, func3]
      print(lst)
      for el in lst:   # 函数名是变量名
          el()
      ```

      ```python
      # 函数名可以作为参数传递给函数
      def my():
          print('我是my')
          
      def proxy(fn):
          print('处理前')
          fn()
          print('处理后')
          
      proxy(my)
      ```

      ```python
      def func():
          print('我是func')
          a = 10
          def inner():
              print('我是inner')
          return inner
      
      func()()  # 先运行func()，然后在返回值上加()
      ```

2. **闭包**

   1. 在内层函数中访问外层函数的局部变量

   2. 闭包的作用

      1. 保护变量不受侵害
      2. 可以让一个变量常驻内存

   3. 写法

      ```python
      def outer():
          a = 10
          def inner():
              print(a)
          return inner
      ```

      

   ```python
   def outer():
       a = 10
       def inner():
           print(a)
       inner()
   outer()
   ```

   ```python
   def outer():
       a = 10  # 对外界不开放
       def inner():
           nonlocal a
           a = 20
           print(a)
       inner()
   outer()
   ```

   ```python
   # 超简易爬虫
   from urllib.request import urlopen
   
   def outer():
       s = urlopen('http://www.521609.com/').read()
       def getCountent():
           return s  # 第一次拿比较慢，之后就很快
       return getCountent
   
   pa = outer()
   ret = pa()
   print(ret)
   print(ret) # 由于内容常驻在内存里，后面的内容不会因为网络原因导致速度很慢
   ```

   ```python
   # 查看是否为闭包
   def func():
       a = 10
       def inner():
           print(a)
       print(inner.__closure__)
       
   func()
   ```

3. **迭代器**

   1. 所有带`__iter__`可以使用`for`循环，是可迭代对象
   2. 可迭代对象可以使用`__iter__()`来获取迭代器
   3. **迭代器**里面有`__next__()`
   4. 可以用`dir`来判断 数据是否可迭代，以及数据是否是迭代器
   5. 惰性机制
   6. 主要是遍历可迭代对象
   7. 只能向前
   8. 省内存

   ```python
   print(dir(str))  # dir查看xx类型的数据可以执行哪些方法
   
   s = '史可心'
   it = s.__iter__() # 获取迭代器
   print(dir(it))
   
   # 只能向前
   # 几乎不占用内存，节省内存
   # 很少直接用，用for循环
   print(it.__next__())
   print(it.__next__())
   ```

   ```python
   # 用迭代器模拟for循环
   lst = ['赵一宁', '史可心', '朱奎峰', '姚明']
   it = lst.__iter__() # 获取迭代器
   while 1:   # 没有内容后报错
       try:   # 避免程序报错
           el = it.__next__()
           print(el)
       except StopIteration:
           break
   ```

   ```python
   lst = ['赵一宁', '史可心', '朱奎峰', '姚明']
   it = lst.__iter__()
   
   # list(参数)把参数循环迭代
   s = list(it)  # 在list中一定存在for循环，会有__next__()
   print(s)
   ```

4. **作业**

   1. 购物车

      ```python
      '''
      让用户输入金额
      选择要购买的商品加入购物车
      当商品的总监超过你的金额提示余额不足
      让用户输入N结算，输入Q退出
      用户退出后提示消费了多少钱，还剩多少
      '''
      goods = [
          {'name':'电脑', 'price','1999'},
          {'name':'鼠标', 'price','10'},
          {'name':'美女', 'price','50'},
          {'name':'游艇', 'price','20'},
          {'name':'火箭', 'price','250'}
      ]
      shop_car = {}  # 键：列表的索引  值：商品的数量
      fei_yong = 0
      money = input('请输入您的金额')
      if money.isdigit():
          # 这是真钱
          # 显示商品
          while 1:
              for i in range(len(goods)):
                  print(i+1, goods[i]['name'],goods[i]['price'])
      
              choose = input('请输入您要购买的商品序号(N结算/Q退出)：')
              if choose.isdigit() and 0 < int(choose) <= len(goods):
                  # 让用户输入商品序号并判断是不是数字，以及在不在正常输入范围内
                  int_index = int(choose) - 1
                  # 通过用户输入的内容减一获取到goods的索引
                  if shop_car.get(int_index) == None:
                      shop_car[int_index] == 1
                  else:
                      shop_car[int_index] += 1
                  # 让用户把商品加入到购物车
              elif choose.upper() == 'N':
                  # 结算  ... == pass
                  for f in shop_car:
                      fei_yong = fei_yong + shio_car[f] * goods[f]['price']
                      if int(money) >= fei_yong:
                          for k in shop_car:
                              print(f'您购买的商品是{goods[k]["name"]},单价{goods[k]["price"]},数量{shop_car[k]}')
                      else:
                          print('余额不足')
                          for i,v in enumerate(shop_car,1): # 枚举
                              print(f'{i}{goods[i]["name"]}{shop_car[v]}')
                          str_del = int(input('请删除商品对应的序号：'))
                          shop_car[str_del -1] = shop_car[str_del - 1] -1
              elif choose.upper() == 'Q':
                  # 退出
                  print(f'您此次共消费{fei_yong},余额{int(money)-fei_yong}')
                  break
              else:
                  print('输入有误，请重新输入')
      else:
          # 这是假钱
          print('请正确输入金额')
      ```

      